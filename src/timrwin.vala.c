/* timrwin.vala.c generated by valac 0.26.2, the Vala compiler
 * generated from timrwin.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>
#include <string.h>
#include <stdlib.h>


#define TIMR_TYPE_APPLICATION_WINDOW (timr_application_window_get_type ())
#define TIMR_APPLICATION_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TIMR_TYPE_APPLICATION_WINDOW, TimrApplicationWindow))
#define TIMR_APPLICATION_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TIMR_TYPE_APPLICATION_WINDOW, TimrApplicationWindowClass))
#define TIMR_IS_APPLICATION_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TIMR_TYPE_APPLICATION_WINDOW))
#define TIMR_IS_APPLICATION_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TIMR_TYPE_APPLICATION_WINDOW))
#define TIMR_APPLICATION_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TIMR_TYPE_APPLICATION_WINDOW, TimrApplicationWindowClass))

typedef struct _TimrApplicationWindow TimrApplicationWindow;
typedef struct _TimrApplicationWindowClass TimrApplicationWindowClass;
typedef struct _TimrApplicationWindowPrivate TimrApplicationWindowPrivate;

#define TIMR_TYPE_ACTIVITY (timr_activity_get_type ())
#define TIMR_ACTIVITY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TIMR_TYPE_ACTIVITY, TimrActivity))
#define TIMR_ACTIVITY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TIMR_TYPE_ACTIVITY, TimrActivityClass))
#define TIMR_IS_ACTIVITY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TIMR_TYPE_ACTIVITY))
#define TIMR_IS_ACTIVITY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TIMR_TYPE_ACTIVITY))
#define TIMR_ACTIVITY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TIMR_TYPE_ACTIVITY, TimrActivityClass))

typedef struct _TimrActivity TimrActivity;
typedef struct _TimrActivityClass TimrActivityClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_timer_destroy0(var) ((var == NULL) ? NULL : (var = (g_timer_destroy (var), NULL)))
#define _timr_activity_unref0(var) ((var == NULL) ? NULL : (var = (timr_activity_unref (var), NULL)))

#define TIMR_TYPE_TIMR (timr_timr_get_type ())
#define TIMR_TIMR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TIMR_TYPE_TIMR, TimrTimr))
#define TIMR_TIMR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TIMR_TYPE_TIMR, TimrTimrClass))
#define TIMR_IS_TIMR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TIMR_TYPE_TIMR))
#define TIMR_IS_TIMR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TIMR_TYPE_TIMR))
#define TIMR_TIMR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TIMR_TYPE_TIMR, TimrTimrClass))

typedef struct _TimrTimr TimrTimr;
typedef struct _TimrTimrClass TimrTimrClass;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _TimrActivityPrivate TimrActivityPrivate;

#define TIMR_TYPE_JOB (timr_job_get_type ())
#define TIMR_JOB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TIMR_TYPE_JOB, TimrJob))
#define TIMR_JOB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TIMR_TYPE_JOB, TimrJobClass))
#define TIMR_IS_JOB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TIMR_TYPE_JOB))
#define TIMR_IS_JOB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TIMR_TYPE_JOB))
#define TIMR_JOB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TIMR_TYPE_JOB, TimrJobClass))

typedef struct _TimrJob TimrJob;
typedef struct _TimrJobClass TimrJobClass;
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))

#define TIMR_TYPE_ACTIVITY_DIALOG (timr_activity_dialog_get_type ())
#define TIMR_ACTIVITY_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TIMR_TYPE_ACTIVITY_DIALOG, TimrActivityDialog))
#define TIMR_ACTIVITY_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TIMR_TYPE_ACTIVITY_DIALOG, TimrActivityDialogClass))
#define TIMR_IS_ACTIVITY_DIALOG(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TIMR_TYPE_ACTIVITY_DIALOG))
#define TIMR_IS_ACTIVITY_DIALOG_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TIMR_TYPE_ACTIVITY_DIALOG))
#define TIMR_ACTIVITY_DIALOG_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TIMR_TYPE_ACTIVITY_DIALOG, TimrActivityDialogClass))

typedef struct _TimrActivityDialog TimrActivityDialog;
typedef struct _TimrActivityDialogClass TimrActivityDialogClass;
typedef struct _Block2Data Block2Data;
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))

struct _TimrApplicationWindow {
	GtkApplicationWindow parent_instance;
	TimrApplicationWindowPrivate * priv;
	GtkTreeStore* activities;
	GtkListStore* clients;
	GtkListStore* jobs;
	GtkTreeStore* clients_jobs;
	GtkTreeView* activities_treeview;
	GtkInfoBar* info_bar;
	GtkLabel* info_bar_primary_label;
	GtkButtonBox* info_bar_action_area;
	TimrActivity* activity;
};

struct _TimrApplicationWindowClass {
	GtkApplicationWindowClass parent_class;
};

struct _TimrApplicationWindowPrivate {
	GtkLabel* elapsed_label;
	GtkEntry* activity_entry;
	GtkButton* timer_button;
	GtkComboBox* job_combobox;
	GTimer* timer;
	gboolean timer_running;
	GdkRGBA red;
	GdkRGBA green;
	GdkRGBA white;
};

struct _TimrActivity {
	GTypeInstance parent_instance;
	volatile int ref_count;
	TimrActivityPrivate * priv;
	gchar* description;
	TimrJob* job;
	gint job_id;
	gchar* job_name;
	gchar* client;
	gchar* type;
	gchar* text;
};

struct _TimrActivityClass {
	GTypeClass parent_class;
	void (*finalize) (TimrActivity *self);
};

struct _Block2Data {
	int _ref_count_;
	TimrApplicationWindow* self;
	TimrActivityDialog* activity_dialog;
};


static gpointer timr_application_window_parent_class = NULL;

GType timr_application_window_get_type (void) G_GNUC_CONST;
gpointer timr_activity_ref (gpointer instance);
void timr_activity_unref (gpointer instance);
GParamSpec* timr_param_spec_activity (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void timr_value_set_activity (GValue* value, gpointer v_object);
void timr_value_take_activity (GValue* value, gpointer v_object);
gpointer timr_value_get_activity (const GValue* value);
GType timr_activity_get_type (void) G_GNUC_CONST;
#define TIMR_APPLICATION_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TIMR_TYPE_APPLICATION_WINDOW, TimrApplicationWindowPrivate))
enum  {
	TIMR_APPLICATION_WINDOW_DUMMY_PROPERTY
};
GType timr_timr_get_type (void) G_GNUC_CONST;
TimrApplicationWindow* timr_application_window_new (TimrTimr* application);
TimrApplicationWindow* timr_application_window_construct (GType object_type, TimrTimr* application);
static gboolean timr_application_window_update_timer (TimrApplicationWindow* self);
static gboolean _timr_application_window_update_timer_gsource_func (gpointer self);
void timr_application_window_on_info_bar_response (TimrApplicationWindow* self, gint response);
static void _timr_application_window_on_info_bar_response_gtk_info_bar_response (GtkInfoBar* _sender, gint response_id, gpointer self);
void timr_application_window_on_activities_treeview_row_activated (TimrApplicationWindow* self, GtkTreePath* path, GtkTreeViewColumn* column);
gpointer timr_job_ref (gpointer instance);
void timr_job_unref (gpointer instance);
GParamSpec* timr_param_spec_job (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void timr_value_set_job (GValue* value, gpointer v_object);
void timr_value_take_job (GValue* value, gpointer v_object);
gpointer timr_value_get_job (const GValue* value);
GType timr_job_get_type (void) G_GNUC_CONST;
static void timr_application_window_timer_start (TimrApplicationWindow* self);
static void _timr_application_window_on_activities_treeview_row_activated_gtk_tree_view_row_activated (GtkTreeView* _sender, GtkTreePath* path, GtkTreeViewColumn* column, gpointer self);
void timr_application_window_on_client_treeview_row_activated (TimrApplicationWindow* self, GtkTreePath* path, GtkTreeViewColumn* column);
static void _timr_application_window_on_client_treeview_row_activated_gtk_tree_view_row_activated (GtkTreeView* _sender, GtkTreePath* path, GtkTreeViewColumn* column, gpointer self);
void timr_application_window_on_client_treeview_name_column_edited (TimrApplicationWindow* self, const gchar* path_str, const gchar* new_text);
static void _timr_application_window_on_client_treeview_name_column_edited_gtk_cell_renderer_text_edited (GtkCellRendererText* _sender, const gchar* path, const gchar* new_text, gpointer self);
void timr_application_window_on_client_treeview_abbrev_column_edited (TimrApplicationWindow* self, const gchar* path_str, const gchar* new_text);
static void _timr_application_window_on_client_treeview_abbrev_column_edited_gtk_cell_renderer_text_edited (GtkCellRendererText* _sender, const gchar* path, const gchar* new_text, gpointer self);
void timr_application_window_on_timer_toggle_button_clicked (TimrApplicationWindow* self, GtkButton* button);
static void timr_application_window_timer_stop (TimrApplicationWindow* self);
static void _timr_application_window_on_timer_toggle_button_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self);
void timr_application_window_on_activity_add_button_clicked (TimrApplicationWindow* self, GtkButton* button);
GType timr_activity_dialog_get_type (void) G_GNUC_CONST;
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
TimrActivityDialog* timr_activity_dialog_new (TimrApplicationWindow* window, GtkTreeStore* clients_jobs);
TimrActivityDialog* timr_activity_dialog_construct (GType object_type, TimrApplicationWindow* window, GtkTreeStore* clients_jobs);
static void __lambda4_ (Block2Data* _data2_, gint response);
gchar* timr_activity_dialog_get_description (TimrActivityDialog* self);
GDateTime* timr_activity_dialog_get_begin (TimrActivityDialog* self);
GDateTime* timr_activity_dialog_get_end (TimrActivityDialog* self);
TimrActivity* timr_activity_new_past (const gchar* description, GDateTime* begin, GDateTime* end);
TimrActivity* timr_activity_construct_past (GType object_type, const gchar* description, GDateTime* begin, GDateTime* end);
gint timr_activity_dialog_get_job_id (TimrActivityDialog* self);
gchar* timr_activity_dialog_get_job_name (TimrActivityDialog* self);
gchar* timr_activity_dialog_get_text (TimrActivityDialog* self);
static void ___lambda4__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self);
static void _timr_application_window_on_activity_add_button_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self);
static void timr_application_window_message (TimrApplicationWindow* self, const gchar* message, GtkMessageType type);
void timr_application_window_error (TimrApplicationWindow* self, const gchar* message);
void timr_application_window_warning (TimrApplicationWindow* self, const gchar* message);
void timr_application_window_info (TimrApplicationWindow* self, const gchar* message);
TimrActivity* timr_activity_new (void);
TimrActivity* timr_activity_construct (GType object_type);
void timr_activity_stop (TimrActivity* self);
static void g_cclosure_user_marshal_VOID__TIMR_ACTIVITY (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
static void timr_application_window_finalize (GObject* obj);


static gboolean _timr_application_window_update_timer_gsource_func (gpointer self) {
	gboolean result;
	result = timr_application_window_update_timer ((TimrApplicationWindow*) self);
	return result;
}


TimrApplicationWindow* timr_application_window_construct (GType object_type, TimrTimr* application) {
	TimrApplicationWindow * self = NULL;
	TimrTimr* _tmp0_ = NULL;
	GTimer* _tmp1_ = NULL;
	GtkLabel* _tmp2_ = NULL;
	GtkButton* _tmp3_ = NULL;
	GdkRGBA _tmp4_ = {0};
	GtkButton* _tmp5_ = NULL;
	GdkRGBA _tmp6_ = {0};
	GtkButton* _tmp7_ = NULL;
	g_return_val_if_fail (application != NULL, NULL);
	_tmp0_ = application;
	self = (TimrApplicationWindow*) g_object_new (object_type, "application", _tmp0_, NULL);
	_tmp1_ = g_timer_new ();
	_g_timer_destroy0 (self->priv->timer);
	self->priv->timer = _tmp1_;
	_tmp2_ = self->priv->elapsed_label;
	gtk_widget_set_size_request ((GtkWidget*) _tmp2_, 120, -1);
	g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 1, _timr_application_window_update_timer_gsource_func, g_object_ref (self), g_object_unref);
	memset (&self->priv->red, 0, sizeof (GdkRGBA));
	memset (&self->priv->green, 0, sizeof (GdkRGBA));
	memset (&self->priv->white, 0, sizeof (GdkRGBA));
	gdk_rgba_parse (&self->priv->red, "#C00000");
	gdk_rgba_parse (&self->priv->green, "#2C7500");
	gdk_rgba_parse (&self->priv->white, "#FFFFFF");
	_tmp3_ = self->priv->timer_button;
	_tmp4_ = self->priv->green;
	gtk_widget_override_background_color ((GtkWidget*) _tmp3_, GTK_STATE_FLAG_NORMAL, &_tmp4_);
	_tmp5_ = self->priv->timer_button;
	_tmp6_ = self->priv->white;
	gtk_widget_override_color ((GtkWidget*) _tmp5_, GTK_STATE_FLAG_NORMAL, &_tmp6_);
	_tmp7_ = self->priv->timer_button;
	gtk_widget_grab_default ((GtkWidget*) _tmp7_);
	return self;
}


TimrApplicationWindow* timr_application_window_new (TimrTimr* application) {
	return timr_application_window_construct (TIMR_TYPE_APPLICATION_WINDOW, application);
}


static gboolean timr_application_window_update_timer (TimrApplicationWindow* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->timer_running;
	if (_tmp0_) {
		guint seconds = 0U;
		GTimer* _tmp1_ = NULL;
		gdouble _tmp2_ = 0.0;
		gchar* mssg = NULL;
		gchar* _tmp3_ = NULL;
		guint _tmp4_ = 0U;
		GtkLabel* _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		_tmp1_ = self->priv->timer;
		_tmp2_ = g_timer_elapsed (_tmp1_, NULL);
		seconds = (guint) _tmp2_;
		_tmp3_ = g_strdup ("");
		mssg = _tmp3_;
		_tmp4_ = seconds;
		if (_tmp4_ < ((guint) 60)) {
			guint _tmp5_ = 0U;
			gchar* _tmp6_ = NULL;
			_tmp5_ = seconds;
			_tmp6_ = g_strdup_printf ("%u sec", _tmp5_);
			_g_free0 (mssg);
			mssg = _tmp6_;
		} else {
			guint _tmp7_ = 0U;
			_tmp7_ = seconds;
			if (_tmp7_ < ((guint) 3600)) {
				guint _tmp8_ = 0U;
				guint _tmp9_ = 0U;
				gchar* _tmp10_ = NULL;
				_tmp8_ = seconds;
				_tmp9_ = seconds;
				_tmp10_ = g_strdup_printf ("%02u:%02u min", _tmp8_ / 60, _tmp9_ % 60);
				_g_free0 (mssg);
				mssg = _tmp10_;
			} else {
				guint _tmp11_ = 0U;
				guint _tmp12_ = 0U;
				gchar* _tmp13_ = NULL;
				_tmp11_ = seconds;
				_tmp12_ = seconds;
				_tmp13_ = g_strdup_printf ("%02u:%02u hrs", _tmp11_ / 3600, _tmp12_ % 3600);
				_g_free0 (mssg);
				mssg = _tmp13_;
			}
		}
		_tmp14_ = self->priv->elapsed_label;
		_tmp15_ = mssg;
		gtk_label_set_text (_tmp14_, _tmp15_);
		_g_free0 (mssg);
	}
	result = TRUE;
	return result;
}


void timr_application_window_on_info_bar_response (TimrApplicationWindow* self, gint response) {
	GtkInfoBar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->info_bar;
	gtk_widget_hide ((GtkWidget*) _tmp0_);
}


static void _timr_application_window_on_info_bar_response_gtk_info_bar_response (GtkInfoBar* _sender, gint response_id, gpointer self) {
	timr_application_window_on_info_bar_response ((TimrApplicationWindow*) self, response_id);
}


void timr_application_window_on_activities_treeview_row_activated (TimrApplicationWindow* self, GtkTreePath* path, GtkTreeViewColumn* column) {
	GtkTreeIter iter = {0};
	gchar* description = NULL;
	GtkTreeStore* _tmp0_ = NULL;
	GtkTreePath* _tmp1_ = NULL;
	GtkTreeIter _tmp2_ = {0};
	GtkTreeStore* _tmp3_ = NULL;
	GtkTreeIter _tmp4_ = {0};
	TimrActivity* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	GtkEntry* _tmp7_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	g_return_if_fail (column != NULL);
	_tmp0_ = self->activities;
	_tmp1_ = path;
	gtk_tree_model_get_iter ((GtkTreeModel*) _tmp0_, &_tmp2_, _tmp1_);
	iter = _tmp2_;
	_tmp3_ = self->activities;
	_tmp4_ = iter;
	gtk_tree_model_get ((GtkTreeModel*) _tmp3_, &_tmp4_, 1, &description, -1);
	_tmp5_ = self->activity;
	_tmp6_ = _tmp5_->job_id;
	g_debug ("timrwin.vala:129: %u\n", (guint) _tmp6_);
	_tmp7_ = self->priv->activity_entry;
	gtk_entry_set_text (_tmp7_, description);
	timr_application_window_timer_start (self);
	_g_free0 (description);
}


static void _timr_application_window_on_activities_treeview_row_activated_gtk_tree_view_row_activated (GtkTreeView* _sender, GtkTreePath* path, GtkTreeViewColumn* column, gpointer self) {
	timr_application_window_on_activities_treeview_row_activated ((TimrApplicationWindow*) self, path, column);
}


void timr_application_window_on_client_treeview_row_activated (TimrApplicationWindow* self, GtkTreePath* path, GtkTreeViewColumn* column) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	g_return_if_fail (column != NULL);
}


static void _timr_application_window_on_client_treeview_row_activated_gtk_tree_view_row_activated (GtkTreeView* _sender, GtkTreePath* path, GtkTreeViewColumn* column, gpointer self) {
	timr_application_window_on_client_treeview_row_activated ((TimrApplicationWindow*) self, path, column);
}


void timr_application_window_on_client_treeview_name_column_edited (TimrApplicationWindow* self, const gchar* path_str, const gchar* new_text) {
	GtkTreeIter iter = {0};
	GtkTreePath* path = NULL;
	gint id = 0;
	const gchar* _tmp0_ = NULL;
	GtkTreePath* _tmp1_ = NULL;
	GtkListStore* _tmp2_ = NULL;
	GtkTreeIter _tmp3_ = {0};
	GtkListStore* _tmp4_ = NULL;
	GtkTreeIter _tmp5_ = {0};
	GtkListStore* _tmp6_ = NULL;
	GtkTreeIter _tmp7_ = {0};
	const gchar* _tmp8_ = NULL;
	gchar* query = NULL;
	const gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path_str != NULL);
	g_return_if_fail (new_text != NULL);
	_tmp0_ = path_str;
	_tmp1_ = gtk_tree_path_new_from_string (_tmp0_);
	_gtk_tree_path_free0 (path);
	path = _tmp1_;
	_tmp2_ = self->clients;
	gtk_tree_model_get_iter ((GtkTreeModel*) _tmp2_, &_tmp3_, path);
	iter = _tmp3_;
	_tmp4_ = self->clients;
	_tmp5_ = iter;
	gtk_tree_model_get ((GtkTreeModel*) _tmp4_, &_tmp5_, 0, &id, -1);
	_tmp6_ = self->clients;
	_tmp7_ = iter;
	_tmp8_ = new_text;
	gtk_list_store_set (_tmp6_, &_tmp7_, 1, _tmp8_, -1);
	_tmp9_ = new_text;
	_tmp10_ = g_strdup_printf ("UPDATE clients SET name='%s' WHERE id=%u\n", _tmp9_, (guint) id);
	query = _tmp10_;
	g_signal_emit_by_name (self, "update-database", query);
	_g_free0 (query);
	_gtk_tree_path_free0 (path);
}


static void _timr_application_window_on_client_treeview_name_column_edited_gtk_cell_renderer_text_edited (GtkCellRendererText* _sender, const gchar* path, const gchar* new_text, gpointer self) {
	timr_application_window_on_client_treeview_name_column_edited ((TimrApplicationWindow*) self, path, new_text);
}


void timr_application_window_on_client_treeview_abbrev_column_edited (TimrApplicationWindow* self, const gchar* path_str, const gchar* new_text) {
	GtkTreeIter iter = {0};
	GtkTreePath* path = NULL;
	gint id = 0;
	const gchar* _tmp0_ = NULL;
	GtkTreePath* _tmp1_ = NULL;
	GtkListStore* _tmp2_ = NULL;
	GtkTreeIter _tmp3_ = {0};
	GtkListStore* _tmp4_ = NULL;
	GtkTreeIter _tmp5_ = {0};
	GtkListStore* _tmp6_ = NULL;
	GtkTreeIter _tmp7_ = {0};
	const gchar* _tmp8_ = NULL;
	gchar* query = NULL;
	const gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path_str != NULL);
	g_return_if_fail (new_text != NULL);
	_tmp0_ = path_str;
	_tmp1_ = gtk_tree_path_new_from_string (_tmp0_);
	_gtk_tree_path_free0 (path);
	path = _tmp1_;
	_tmp2_ = self->clients;
	gtk_tree_model_get_iter ((GtkTreeModel*) _tmp2_, &_tmp3_, path);
	iter = _tmp3_;
	_tmp4_ = self->clients;
	_tmp5_ = iter;
	gtk_tree_model_get ((GtkTreeModel*) _tmp4_, &_tmp5_, 0, &id, -1);
	_tmp6_ = self->clients;
	_tmp7_ = iter;
	_tmp8_ = new_text;
	gtk_list_store_set (_tmp6_, &_tmp7_, 2, _tmp8_, -1);
	_tmp9_ = new_text;
	_tmp10_ = g_strdup_printf ("UPDATE clients SET abbrev='%s' WHERE id=%u\n", _tmp9_, (guint) id);
	query = _tmp10_;
	g_signal_emit_by_name (self, "update-database", query);
	_g_free0 (query);
	_gtk_tree_path_free0 (path);
}


static void _timr_application_window_on_client_treeview_abbrev_column_edited_gtk_cell_renderer_text_edited (GtkCellRendererText* _sender, const gchar* path, const gchar* new_text, gpointer self) {
	timr_application_window_on_client_treeview_abbrev_column_edited ((TimrApplicationWindow*) self, path, new_text);
}


void timr_application_window_on_timer_toggle_button_clicked (TimrApplicationWindow* self, GtkButton* button) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (button != NULL);
	_tmp1_ = self->priv->timer_running;
	if (_tmp1_) {
		TimrActivity* _tmp2_ = NULL;
		_tmp2_ = self->activity;
		_tmp0_ = _tmp2_ != NULL;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		timr_application_window_timer_stop (self);
	} else {
		timr_application_window_timer_start (self);
	}
}


static void _timr_application_window_on_timer_toggle_button_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	timr_application_window_on_timer_toggle_button_clicked ((TimrApplicationWindow*) self, _sender);
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		TimrApplicationWindow* self;
		self = _data2_->self;
		_g_object_unref0 (_data2_->activity_dialog);
		_g_object_unref0 (self);
		g_slice_free (Block2Data, _data2_);
	}
}


static void __lambda4_ (Block2Data* _data2_, gint response) {
	TimrApplicationWindow* self;
	gint _tmp0_ = 0;
	self = _data2_->self;
	_tmp0_ = response;
	if (_tmp0_ == ((gint) GTK_RESPONSE_OK)) {
		TimrActivity* activity = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GDateTime* _tmp3_ = NULL;
		GDateTime* _tmp4_ = NULL;
		GDateTime* _tmp5_ = NULL;
		GDateTime* _tmp6_ = NULL;
		TimrActivity* _tmp7_ = NULL;
		TimrActivity* _tmp8_ = NULL;
		TimrActivity* _tmp9_ = NULL;
		gint _tmp10_ = 0;
		TimrActivity* _tmp11_ = NULL;
		gchar* _tmp12_ = NULL;
		TimrActivity* _tmp13_ = NULL;
		gchar* _tmp14_ = NULL;
		TimrActivity* _tmp15_ = NULL;
		_tmp1_ = timr_activity_dialog_get_description (_data2_->activity_dialog);
		_tmp2_ = _tmp1_;
		_tmp3_ = timr_activity_dialog_get_begin (_data2_->activity_dialog);
		_tmp4_ = _tmp3_;
		_tmp5_ = timr_activity_dialog_get_end (_data2_->activity_dialog);
		_tmp6_ = _tmp5_;
		_tmp7_ = timr_activity_new_past (_tmp2_, _tmp4_, _tmp6_);
		_tmp8_ = _tmp7_;
		_g_date_time_unref0 (_tmp6_);
		_g_date_time_unref0 (_tmp4_);
		_g_free0 (_tmp2_);
		activity = _tmp8_;
		_tmp9_ = activity;
		_tmp10_ = timr_activity_dialog_get_job_id (_data2_->activity_dialog);
		_tmp9_->job_id = _tmp10_;
		_tmp11_ = activity;
		_tmp12_ = timr_activity_dialog_get_job_name (_data2_->activity_dialog);
		_g_free0 (_tmp11_->job_name);
		_tmp11_->job_name = _tmp12_;
		_tmp13_ = activity;
		_tmp14_ = timr_activity_dialog_get_text (_data2_->activity_dialog);
		_g_free0 (_tmp13_->text);
		_tmp13_->text = _tmp14_;
		_tmp15_ = activity;
		g_signal_emit_by_name (self, "activity-stopped", _tmp15_);
		_timr_activity_unref0 (activity);
	}
	gtk_widget_destroy ((GtkWidget*) _data2_->activity_dialog);
}


static void ___lambda4__gtk_dialog_response (GtkDialog* _sender, gint response_id, gpointer self) {
	__lambda4_ (self, response_id);
}


void timr_application_window_on_activity_add_button_clicked (TimrApplicationWindow* self, GtkButton* button) {
	Block2Data* _data2_;
	GtkTreeStore* _tmp0_ = NULL;
	TimrActivityDialog* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (button != NULL);
	_data2_ = g_slice_new0 (Block2Data);
	_data2_->_ref_count_ = 1;
	_data2_->self = g_object_ref (self);
	_tmp0_ = self->clients_jobs;
	_tmp1_ = timr_activity_dialog_new (self, _tmp0_);
	g_object_ref_sink (_tmp1_);
	_data2_->activity_dialog = _tmp1_;
	g_signal_connect_data ((GtkDialog*) _data2_->activity_dialog, "response", (GCallback) ___lambda4__gtk_dialog_response, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
	gtk_dialog_run ((GtkDialog*) _data2_->activity_dialog);
	block2_data_unref (_data2_);
	_data2_ = NULL;
}


static void _timr_application_window_on_activity_add_button_clicked_gtk_button_clicked (GtkButton* _sender, gpointer self) {
	timr_application_window_on_activity_add_button_clicked ((TimrApplicationWindow*) self, _sender);
}


static void timr_application_window_message (TimrApplicationWindow* self, const gchar* message, GtkMessageType type) {
	GtkLabel* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GtkInfoBar* _tmp2_ = NULL;
	GtkMessageType _tmp3_ = 0;
	GtkInfoBar* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (message != NULL);
	_tmp0_ = self->info_bar_primary_label;
	_tmp1_ = message;
	gtk_label_set_markup (_tmp0_, _tmp1_);
	_tmp2_ = self->info_bar;
	_tmp3_ = type;
	gtk_info_bar_set_message_type (_tmp2_, _tmp3_);
	_tmp4_ = self->info_bar;
	gtk_widget_show ((GtkWidget*) _tmp4_);
}


void timr_application_window_error (TimrApplicationWindow* self, const gchar* message) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (message != NULL);
	_tmp0_ = message;
	timr_application_window_message (self, _tmp0_, GTK_MESSAGE_ERROR);
}


void timr_application_window_warning (TimrApplicationWindow* self, const gchar* message) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (message != NULL);
	_tmp0_ = message;
	timr_application_window_message (self, _tmp0_, GTK_MESSAGE_WARNING);
}


void timr_application_window_info (TimrApplicationWindow* self, const gchar* message) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (message != NULL);
	_tmp0_ = message;
	timr_application_window_message (self, _tmp0_, GTK_MESSAGE_INFO);
}


static void timr_application_window_timer_start (TimrApplicationWindow* self) {
	TimrActivity* _tmp0_ = NULL;
	GTimer* _tmp1_ = NULL;
	GtkButton* _tmp2_ = NULL;
	GtkButton* _tmp3_ = NULL;
	GdkRGBA _tmp4_ = {0};
	GtkButton* _tmp5_ = NULL;
	GdkRGBA _tmp6_ = {0};
	g_return_if_fail (self != NULL);
	_tmp0_ = timr_activity_new ();
	_timr_activity_unref0 (self->activity);
	self->activity = _tmp0_;
	_tmp1_ = self->priv->timer;
	g_timer_start (_tmp1_);
	self->priv->timer_running = TRUE;
	_tmp2_ = self->priv->timer_button;
	gtk_button_set_label (_tmp2_, "Stop timer");
	_tmp3_ = self->priv->timer_button;
	_tmp4_ = self->priv->red;
	gtk_widget_override_background_color ((GtkWidget*) _tmp3_, GTK_STATE_FLAG_NORMAL, &_tmp4_);
	_tmp5_ = self->priv->timer_button;
	_tmp6_ = self->priv->white;
	gtk_widget_override_color ((GtkWidget*) _tmp5_, GTK_STATE_FLAG_NORMAL, &_tmp6_);
}


static void timr_application_window_timer_stop (TimrApplicationWindow* self) {
	GtkTreeIter iter = {0};
	gint job_id = 0;
	gchar* job_display_name = NULL;
	gchar* _tmp0_ = NULL;
	gchar* job_name = NULL;
	gchar* job_abbrev = NULL;
	TimrActivity* _tmp1_ = NULL;
	TimrActivity* _tmp2_ = NULL;
	GtkEntry* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	GtkComboBox* _tmp6_ = NULL;
	GtkTreeIter _tmp7_ = {0};
	gboolean _tmp8_ = FALSE;
	TimrActivity* _tmp14_ = NULL;
	gint _tmp15_ = 0;
	TimrActivity* _tmp16_ = NULL;
	const gchar* _tmp17_ = NULL;
	gchar* _tmp18_ = NULL;
	TimrActivity* _tmp19_ = NULL;
	const gchar* _tmp20_ = NULL;
	gchar* _tmp21_ = NULL;
	gchar* _tmp22_ = NULL;
	gchar* _tmp23_ = NULL;
	gchar* _tmp24_ = NULL;
	TimrActivity* _tmp25_ = NULL;
	const gchar* _tmp26_ = NULL;
	gchar* _tmp27_ = NULL;
	GTimer* _tmp28_ = NULL;
	GtkButton* _tmp29_ = NULL;
	GtkButton* _tmp30_ = NULL;
	GdkRGBA _tmp31_ = {0};
	GtkButton* _tmp32_ = NULL;
	GdkRGBA _tmp33_ = {0};
	GtkLabel* _tmp34_ = NULL;
	GtkEntry* _tmp35_ = NULL;
	GtkComboBox* _tmp36_ = NULL;
	TimrActivity* _tmp37_ = NULL;
	g_return_if_fail (self != NULL);
	job_id = 0;
	_tmp0_ = g_strdup ("unknown job");
	job_display_name = _tmp0_;
	_tmp1_ = self->activity;
	timr_activity_stop (_tmp1_);
	_tmp2_ = self->activity;
	_tmp3_ = self->priv->activity_entry;
	_tmp4_ = gtk_entry_get_text (_tmp3_);
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 (_tmp2_->description);
	_tmp2_->description = _tmp5_;
	_tmp6_ = self->priv->job_combobox;
	_tmp8_ = gtk_combo_box_get_active_iter (_tmp6_, &_tmp7_);
	iter = _tmp7_;
	if (_tmp8_) {
		GtkTreeStore* _tmp9_ = NULL;
		GtkTreeIter _tmp10_ = {0};
		gint _tmp11_ = 0;
		_tmp9_ = self->clients_jobs;
		_tmp10_ = iter;
		_tmp11_ = gtk_tree_store_iter_depth (_tmp9_, &_tmp10_);
		if (_tmp11_ > 0) {
			GtkTreeStore* _tmp12_ = NULL;
			GtkTreeIter _tmp13_ = {0};
			_tmp12_ = self->clients_jobs;
			_tmp13_ = iter;
			gtk_tree_model_get ((GtkTreeModel*) _tmp12_, &_tmp13_, 0, &job_id, 1, &job_name, 2, &job_abbrev, 3, &job_display_name, -1);
		}
	}
	_tmp14_ = self->activity;
	_tmp15_ = job_id;
	_tmp14_->job_id = _tmp15_;
	_tmp16_ = self->activity;
	_tmp17_ = job_display_name;
	_tmp18_ = g_strdup (_tmp17_);
	_g_free0 (_tmp16_->job_name);
	_tmp16_->job_name = _tmp18_;
	_tmp19_ = self->activity;
	_tmp20_ = job_display_name;
	_tmp21_ = g_strconcat ("<b>", _tmp20_, NULL);
	_tmp22_ = _tmp21_;
	_tmp23_ = g_strconcat (_tmp22_, "</b>\n", NULL);
	_tmp24_ = _tmp23_;
	_tmp25_ = self->activity;
	_tmp26_ = _tmp25_->description;
	_tmp27_ = g_strconcat (_tmp24_, _tmp26_, NULL);
	_g_free0 (_tmp19_->text);
	_tmp19_->text = _tmp27_;
	_g_free0 (_tmp24_);
	_g_free0 (_tmp22_);
	_tmp28_ = self->priv->timer;
	g_timer_stop (_tmp28_);
	self->priv->timer_running = FALSE;
	_tmp29_ = self->priv->timer_button;
	gtk_button_set_label (_tmp29_, "Start timer");
	_tmp30_ = self->priv->timer_button;
	_tmp31_ = self->priv->green;
	gtk_widget_override_background_color ((GtkWidget*) _tmp30_, GTK_STATE_FLAG_NORMAL, &_tmp31_);
	_tmp32_ = self->priv->timer_button;
	_tmp33_ = self->priv->white;
	gtk_widget_override_color ((GtkWidget*) _tmp32_, GTK_STATE_FLAG_NORMAL, &_tmp33_);
	_tmp34_ = self->priv->elapsed_label;
	gtk_label_set_text (_tmp34_, "0 sec");
	_tmp35_ = self->priv->activity_entry;
	gtk_entry_set_text (_tmp35_, "");
	_tmp36_ = self->priv->job_combobox;
	gtk_combo_box_set_active (_tmp36_, 0);
	_tmp37_ = self->activity;
	g_signal_emit_by_name (self, "activity-stopped", _tmp37_);
	_g_free0 (job_abbrev);
	_g_free0 (job_name);
	_g_free0 (job_display_name);
}


static void g_cclosure_user_marshal_VOID__TIMR_ACTIVITY (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__TIMR_ACTIVITY) (gpointer data1, gpointer arg_1, gpointer data2);
	register GMarshalFunc_VOID__TIMR_ACTIVITY callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__TIMR_ACTIVITY) (marshal_data ? marshal_data : cc->callback);
	callback (data1, timr_value_get_activity (param_values + 1), data2);
}


static void timr_application_window_class_init (TimrApplicationWindowClass * klass) {
	gint TimrApplicationWindow_private_offset;
	timr_application_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (TimrApplicationWindowPrivate));
	G_OBJECT_CLASS (klass)->finalize = timr_application_window_finalize;
	TimrApplicationWindow_private_offset = g_type_class_get_instance_private_offset (klass);
	gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass), "/de/hannenz/timr/timr.ui");
	g_signal_new ("activity_stopped", TIMR_TYPE_APPLICATION_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__TIMR_ACTIVITY, G_TYPE_NONE, 1, TIMR_TYPE_ACTIVITY);
	g_signal_new ("update_database", TIMR_TYPE_APPLICATION_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	g_signal_new ("client_edited", TIMR_TYPE_APPLICATION_WINDOW, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "elapsed_label", FALSE, TimrApplicationWindow_private_offset + G_STRUCT_OFFSET (TimrApplicationWindowPrivate, elapsed_label));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "activity_entry", FALSE, TimrApplicationWindow_private_offset + G_STRUCT_OFFSET (TimrApplicationWindowPrivate, activity_entry));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "timer_button", FALSE, TimrApplicationWindow_private_offset + G_STRUCT_OFFSET (TimrApplicationWindowPrivate, timer_button));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "job_combobox", FALSE, TimrApplicationWindow_private_offset + G_STRUCT_OFFSET (TimrApplicationWindowPrivate, job_combobox));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "activities", FALSE, G_STRUCT_OFFSET (TimrApplicationWindow, activities));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "clients", FALSE, G_STRUCT_OFFSET (TimrApplicationWindow, clients));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "jobs", FALSE, G_STRUCT_OFFSET (TimrApplicationWindow, jobs));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "clients_jobs", FALSE, G_STRUCT_OFFSET (TimrApplicationWindow, clients_jobs));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "activities_treeview", FALSE, G_STRUCT_OFFSET (TimrApplicationWindow, activities_treeview));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "info_bar", FALSE, G_STRUCT_OFFSET (TimrApplicationWindow, info_bar));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "info_bar_primary_label", FALSE, G_STRUCT_OFFSET (TimrApplicationWindow, info_bar_primary_label));
	gtk_widget_class_bind_template_child_full (GTK_WIDGET_CLASS (klass), "info_bar_action_area", FALSE, G_STRUCT_OFFSET (TimrApplicationWindow, info_bar_action_area));
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "on_info_bar_response", G_CALLBACK(_timr_application_window_on_info_bar_response_gtk_info_bar_response));
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "on_activities_treeview_row_activated", G_CALLBACK(_timr_application_window_on_activities_treeview_row_activated_gtk_tree_view_row_activated));
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "on_client_treeview_row_activated", G_CALLBACK(_timr_application_window_on_client_treeview_row_activated_gtk_tree_view_row_activated));
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "on_client_treeview_name_column_edited", G_CALLBACK(_timr_application_window_on_client_treeview_name_column_edited_gtk_cell_renderer_text_edited));
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "on_client_treeview_abbrev_column_edited", G_CALLBACK(_timr_application_window_on_client_treeview_abbrev_column_edited_gtk_cell_renderer_text_edited));
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "on_timer_toggle_button_clicked", G_CALLBACK(_timr_application_window_on_timer_toggle_button_clicked_gtk_button_clicked));
	gtk_widget_class_bind_template_callback_full (GTK_WIDGET_CLASS (klass), "on_activity_add_button_clicked", G_CALLBACK(_timr_application_window_on_activity_add_button_clicked_gtk_button_clicked));
}


static void timr_application_window_instance_init (TimrApplicationWindow * self) {
	self->priv = TIMR_APPLICATION_WINDOW_GET_PRIVATE (self);
	self->priv->timer_running = FALSE;
	gtk_widget_init_template (GTK_WIDGET (self));
}


static void timr_application_window_finalize (GObject* obj) {
	TimrApplicationWindow * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TIMR_TYPE_APPLICATION_WINDOW, TimrApplicationWindow);
	_g_object_unref0 (self->priv->elapsed_label);
	_g_object_unref0 (self->priv->activity_entry);
	_g_object_unref0 (self->priv->timer_button);
	_g_object_unref0 (self->priv->job_combobox);
	_g_object_unref0 (self->activities);
	_g_object_unref0 (self->clients);
	_g_object_unref0 (self->jobs);
	_g_object_unref0 (self->clients_jobs);
	_g_object_unref0 (self->activities_treeview);
	_g_object_unref0 (self->info_bar);
	_g_object_unref0 (self->info_bar_primary_label);
	_g_object_unref0 (self->info_bar_action_area);
	_g_timer_destroy0 (self->priv->timer);
	_timr_activity_unref0 (self->activity);
	G_OBJECT_CLASS (timr_application_window_parent_class)->finalize (obj);
}


GType timr_application_window_get_type (void) {
	static volatile gsize timr_application_window_type_id__volatile = 0;
	if (g_once_init_enter (&timr_application_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TimrApplicationWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) timr_application_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TimrApplicationWindow), 0, (GInstanceInitFunc) timr_application_window_instance_init, NULL };
		GType timr_application_window_type_id;
		timr_application_window_type_id = g_type_register_static (gtk_application_window_get_type (), "TimrApplicationWindow", &g_define_type_info, 0);
		g_once_init_leave (&timr_application_window_type_id__volatile, timr_application_window_type_id);
	}
	return timr_application_window_type_id__volatile;
}



